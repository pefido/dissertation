\chapter{Integration Implementation}
\label{cha:integration_implementation}

In this chapter we will focus on the implementation of the integration, describing the work done in each component, the connection between components and emphasizing some important implementation details.\par
	To cover this chapter we will start by
\begin{enumerate*}[(i)]

\item describing the supported data types and how they translate between systems, then we will 

\item enumerate the changes we deemed needed to Antidote, which are mainly an afford to make the system more language abstract. After this, we will show as well the 

\item changes made to Legion, in the objects server. After the component's description we will get a more in depth description of the update propagation flow, from

\item Legion to Antidote, and then from

\item Antidote to Legion.

\end{enumerate*}	

\section{Supported Data Types}
\label{sec:supported_data_types}
This section describes the supported data types from Legion and how they translate to the correspondent Antidote data types.

\subsection{Sets}
\label{sec:sets}
This integration supports sets as one of the CRDTs that Legion offers. More precisely, the supported sets in this integration are operation sets.\par
	Legion holds it's data types in the objectStore component and internally implements this operation set as a OR-Set, as described in \cite{crdt}. An ORSet is a CmRDT, which characterizes it self as an operation based CRDT that propagates it's changes based on the operations done. This suits our model of operation propagation.\par
	In order to store this data type in Antidote, we naturally also chose an OR-Set, as Antidote supports it natively.\par
	When an operation is done in a system's OR-Set, the same operation will be issued to the other system's OR-Set. This process is straight forward, but we need to keep track of the unique identifiers that pair with each element of the set. This is important, for example, when deleting an element from the set. We want to delete a particular element with a unique id, not any element that matches. Because of this, there are also metadata sets in Antidote that store this correspondence between Legion and Antidote unique tokens.

\subsection{Counters}
\label{sec:counters}
One of the supported data types in Legion are Counters. They are internally implemented as a state based PN-Counter, as described in \cite{crdt}. Using a CvRDT means that the object will converge by propagating and merging its state. In order to match this data type in Antidote, we used an operation based PN-Counter.\par
	To make the two counters synchronized, we must execute increments and decrements based on who issued the update. When a counter is updated in Legion, since this is a state based PN-Counter, its internal state will be propagated to at least one object server. With the counter's state in our hands, we will make a diff based on the current state of the Antidote's counter, the changes are then applied, in order to get the same state on both. When updating a counter in Antidote, since this one is operation based, we can simply apply the increments and decrements directly in the object server. In both cases we have to keep a meta data set to store the correspondence between operation IDs. This is necessary to avoid duplicated operations when more than one object server catches the same update.

\section{Antidote changes}
\label{sec:antidote_changes}
In this section we will describe the changes to Antidote that were needed in order to make this integration possible.\par
	Antidote is a storage system based in Riak Core and it is still in a fresh stage of development. It is written in Erlang and it offers two interfaces for clients to communicate with: 
\begin{enumerate*}[(i)]
\item distributed Erlang interface, and 
\item protocol buffer interface.
\end{enumerate*}
\par
	The first one uses distributed Erlang and can only be used by an Erlang client, which is of no use to us in the integration.\par
	The second one uses google's protocol buffer serialization mechanism to offer an interface that can be language abstract. This would suit our needs since we want to be able to communicate with Antidote from a Legion objects server written in Javascript. In order to use this interface, some changes need to be made. Some protocol buffer message values are raw Erlang binaries, which are extremely difficult to encode/ decode in Javascript. These need to be changed to a language independent format. Also, some important methods that are available in the distributed Erlang interface need to be included in the protocol buffer API. In order to develop this integration, the following requirements need to be met on Antidote:
	\begin{itemize}
	\item protocol buffer messages can only contain basic data types, like numbers or strings for the interface to be language abstract.
	\item API methods that besides the object's value, also return it's hidden information, like commit timestamps and unique identifiers.
	\item An API method that returns the content of the system log since a certain timestamp. 
	\end{itemize}
\par
	With the help from Antidote's development team, these requirements were implemented. The missing interface methods were already implemented internally, so it was only required to make an interface method to export those.\par
	In order to make the interface language abstract, it was implemented a JSON data structure over protocol buffer messages. This was possible by having a JSON encoding/ decoding component in Antidote's protocol buffer interface. Although this might not be the best solution, since it partially defeats the purpose of protocol buffers, it was the more practical solution regarding this thesis time span.\par
	Summing up, in listing \ref{lst:proto1} we show the protocol buffer interface methods before this change, and listing \ref{lst:proto2} shows the only method that these were encapsulated into, where the 'value' field is a JSON object with the request.\par
	These changes enable us to proceed with the system integration. Algorithm \ref{antidote_interaction} shows how Antidote interacts with the other components. When handling a write request, Antidote propagates the update internally and replies with information from that transaction. When the request is a read, Antidote replies with the object itself, including unique identifiers and transaction information. The requests can be paired with a timestamp that represents the system snapshot on which the read/ write will be executed. The internal object update propagation can be intra-datacenter or inter-datacenter, depending on the current system setup.
	
\begin{algorithm}
\caption{Antidote request interaction}\label{antidote_interaction}
\begin{algorithmic}[1]
\algblock{Upon}{End}
\Upon { $request$:}
  \algblock{Switch}{End}
  \Switch { $request.type$}
    \algblock{case}{End}
    \case { "write"}
      \State {$answer$ $\gets$ updateObjects($request.objectId$, $request.timestamp$)}
      \State {Send reply($answer$)}
    \End
    \case { "read"}
    \State {$answer$ $\gets$ getObjects($request.objectId, request.timestamp$)}
    \State {Send reply($answer$)}
    \End
  \End
\End
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption={Protocol Buffer interface methods before},label={lst:proto1}]
message ApbReadObjects {
  repeated ApbBoundObject boundobjects = 1;
  required bytes transaction_descriptor = 2;
}

message ApbGetObjects {
  repeated ApbBoundObject boundobjects = 2;
}

message ApbUpdateObjects {
  repeated ApbUpdateOp updates = 1;
  required bytes transaction_descriptor = 2;
}

message ApbStartTransaction {
  required ApbVectorclock timestamp = 1;
  optional ApbTxnProperties properties = 2;
}

message ApbCommitTransaction {
  required bytes transaction_descriptor = 1;
}

message ApbGetLogOperations {
  repeated ApbVectorclock timestamps = 2;
  repeated ApbBoundObject boundobjects = 3;
}
\end{lstlisting}

\begin{lstlisting}[caption={Protocol Buffer interface methods after},label={lst:proto2}]
message ApbJsonRequest {
  required bytes value = 1;
}
\end{lstlisting}

\section{Legion changes}
\label{sec:legion_changes}
The majority of the code from the implementation was developed in Legion, more specifically in the objects server component. This is where the logic of the synchronization resides.\par
	To manage the synchronization between Legion and Antidote there two main parts that needed to be implemented: 
\begin{enumerate*}[(i)]
\item propagate updates that reach the objects server from a legion node, and 
\item periodically check for updates that were issued directly to Antidote.
\end{enumerate*}

\subsection{Legion to Antidote flow}
\label{sec:legion_changes_legion_to_antidote_flow}
As mentioned before in \ref{sec:legion_to_antidote_flow}, every update issued by a Legion node will be caught in the objects server. Algorithm \ref{objects_server_update_propagation} shows the steps needed for the objects server to propagate each message. A message that reaches the objects server can be of several types, we want to parse the ones having the type 'contentFromNetwork'. By catching this event we know that an update has been issued, so now we can parse the message and get the details that we need in order to propagate the operation to Antidote. Listing \ref{lst:update_example} shows an example of an incoming update message.\par
	After parsing the message, a request is made to Antidote in order to check if that operation was already done. In case it was not, two separate requests are sent to Antidote, one for the actual data, and the other for the meta-data. To write the data in Antidote, the protocol buffer interface is used by calling the "updateObjects" method with the element and operation. To write the meta-data, we rely on the ZooKeeper service to guarantee mutual exclusion when updating meta-data objects. Legion's objects server needs to obtain a lock before the update is done, releasing it after. ZooKeeper acts as a centralized coordination service, by granting locks and maintaining the locking state per object. The meta-data held in Antidote represents the operations that were already propagated from Legion to Antidote, as well as CRDT specific unique identifiers.
	
\begin{algorithm}
\caption{Objects Server Legion to Antidote update propagation}\label{objects_server_update_propagation}
\begin{algorithmic}[1]
\algblock{Upon}{End}
\Upon { message:}
  \If {$message.type$ = "contentFromNetwork"}
      \State {$opInfo$ $\gets$ parse($message.content$)}
      \State {$doneOps$ $\gets$ antidote.getObjects($doneOps$)}
      \If {!($opInfo.id$ in $doneOps$)}
        %\State {zooKeeper.lock($opInfo.objectId$)}
        \State {antidote.updateObjects($doneOps$, add, $opInfo.id$)}
        %\State {zooKeeper.unlock($opInfo.objectId$)}
        \State {antidote.updateObjects($opInfo.objectID$, $opInfo.op$, $lastSeenTimestamp$)}
        \Upon { reply($txInfo$):}
          \State {zooKeeper.lock($opInfo.objectId$)}
          \If {$opInfo.CRDTType$ = 'set'}
            \State {$metadata$ $\gets$ parse($opInfo$, $txInfo$)}
            \State {antidote.updateObjects($metadata.objectID$, $metadata.op$, $metadata.tokens$)}
          \ElsIf {$opInfo.CRDTType$ = 'counter'}
            \State {$metadata$ $\gets$ parse($opInfo$, $txInfo$)}
            \State {antidote.updateObjects($metadata.objectID$, $metadata.op$, $metadata.opId$)}
          \EndIf
          \State {zooKeeper.unlock($opInfo.objectId$)}
        \End
      \EndIf
  \EndIf
\End
\end{algorithmic}
\end{algorithm}
	

\begin{lstlisting}[caption={Legion update content message example},label={lst:update_example}]
{
  type:"OS:C",
  sender:1,
  ID:7012120591,
  content:{
    type:"OPLIST",
    objectID:"objectID2",
    operations:[
      {
        dependencyVV:{},
        opID:1,
        result:{
          element:"a",
          unique:"6651411189259640"
        },
        opName:"add",
        clientID:"1"
      }
    ]
  },
  destination:"localhost:8004"
}
\end{lstlisting}

\subsection{Antidote to Legion flow}
\label{sec:legion_changes_antidote to legion flow}
As mentioned before in \ref{sec:antidote_to_legion_flow}, the process of propagating updates from Antidote to the Legion network is based on periodic probing.\par
	Algorithm \ref{objects_server_update_propagation2} shows the pseudo-code of the objects server work in propagating updates from Antidote to Legion. In order to periodically check for new updates in Antidote, there is a method that starts running when a Legion's objects server starts. This method will fire an event every two seconds and fetches Antidote's operations log. This request is done via the protocol buffer interface and it contains the elements to search for, as well as a given system timestamp that represents the last seen state of Antidote by that Legion objects server. The reply will be a list of executed operations since the system snapshot given by the timestamp. An example of the operations log response is shown in listing \ref{lst:log_example}.\par
	If there exists new updates to the element, these will be locally executed in the objects server, and then propagated to the all the Legion nodes. The operation id is recorded in the objects server as executed. Another request is made to Antidote, in order to keep the track of the correspondent unique identifiers from Antidote to Legion.\par
	At the end of this process we also need to update the last seen timestamp of Antidote's state in the objects server. This timestamp corresponds to the commit time of the last update in the operations log.
	
\begin{algorithm}[H]
\caption{Objects Server Antidote to Legion update propagation}\label{objects_server_update_propagation2}
\begin{algorithmic}[1]
\algblock{Every}{End}
\Every { 2 seconds:}
      \State {$updateList$ $\gets$ getLogOperations($elements$, $lastSeenTimestamp$)}
      \ForEach {$update \in updateList$}
        \State {$identifiers$ $\gets$ execute($update$)}
        \State {propagate($update$)}
        \State Send request($upxdate.Id, identifiers$)
      \EndFor
      \State {$lastSeenTimestamp \gets updateList.timestamp$}
\End
\end{algorithmic}
\end{algorithm}
	
\begin{lstlisting}[caption={Antidote log response example},label={lst:log_example}]
{log_operations:[
  {
    clocksi_payload:{
        key: {json_value:"objectID2"}
    },
    type:"crdt_orset",
    update:{
      add:[
        {json_value:"b"},
        {binary64:"YySEUYb9uvr4EMO3glI8BWTKurw="}
      ]
    },
       commit_time:[
         {dcid:["antidote@127.0.0.1",1472,53665,947954]},
         1472053805871290
   ]
  }
]}
\end{lstlisting}

\section{Proxy Development}
\label{sec:proxy_development}
This component, as mentioned in \ref{sec:architecture_overview}, links Antidote to the other components that need to exchange data.\par
	The integration proxy as two main objectives in this system: 
\begin{enumerate*}[(i)]
\item work as a proxy by relaying the requests from both Antidote clients and Legion's objects servers to Antidote, and 
\item handle the meta-data stored in Antidote, by always keeping it updated.
\end{enumerate*}
Algorithm \ref{integration_proxy_algorithm} depict the logic of the work done by the integration proxy.\par
	In order to receive requests from the above mentioned components, this proxy acts as an HTTP server that exposes an interface with API routes to communicate with Antidote. The available API is shown in listing \ref{lst:proxy_api}. The API methods are simple, the methods are the same for all data types, being this resolved by the route in case of a GET or in the request payload in case of a PUT.\par
	After this, the proxy will need to send a request of it's own to Antidote. In order to do so, we make use of the protocol buffer interface mentioned in \ref{lst:proto2}.\par
	The second goal of the proxy is to keep the system's meta-data updated in Antidote. To attain this, every time an update is requested to the proxy, this one has to make a request to Antidote in order to update the object, and another request to update the meta-data object. When handling an object's meta-data, there can be data corruption when more then one update is done concurrently over the same object, so in order to avoid this, we used the ZooKeeper system to act as a distributed locking mechanism that makes each update request to acquire a lock. This guarantees that we have mutual exclusion per object when manipulating the meta-data objects.\par
	Every Antidote object as a related meta-data object. For example, if we have a set called 'objectID2', then there is a meta-data object called 'objectID2\_tokens' that contains a set of pairs that represents the correspondence between Antidote and Legion unique identifiers.
	
\begin{lstlisting}[caption={Integration proxy API},label={lst:proxy_api}]
server.route({
  method: 'GET',
  path: '/ping',
  handler: function (request, reply) {
    ...
  }
}

server.route({
  method: 'GET',
  path: '/readObjects/{key}/{type}',
  handler: function (request, reply) {
    ...
  }
}

server.route({
  method: 'GET',
  path: '/getObjects/{key}/{type}',
  handler: function (request, reply) {
    ...
  }
}

server.route({
  method: 'PUT',
  path: '/updateObjects',
  handler: function (request, reply) {
    ...
  }
}

server.route({
  method: 'GET',
  path: '/getLogOps/{key}/{type}/{vClock}',
  handler: function (request, reply) {
    ...
  }
}
\end{lstlisting}

\begin{algorithm}
\caption{Integration Proxy request handling}
\label{integration_proxy_algorithm}
\begin{algorithmic}[1]
\algblock{Upon}{End}
\Upon { $request$:}
  \algblock{Switch}{End}
  \Switch { $request.type$}
    \algblock{case}{End}
    \case { "write"}
      \State {$data$, $metadata$ $\gets$ parse($request$)}
      \State {lock($metadata$)}
      \State {Send request($metadata$)}
      \Upon { $answer$:}
        \State {unlock($metadata$)}
      \End
      \State {Send request($data$)}
      \Upon { $answer$:}
        \State {Send reply($answer$)}
      \End
    \End
    \case { "read"}
    \State {$data$ $\gets$ parse($request$)}
    \State {Send request($data$)}
    \Upon { $answer$:}
      \State {Send reply($answer$)}
    \End
    \End
  \End
\End
\end{algorithmic}
\end{algorithm}


%\section{Operation Propagation}
%\label{sec:operation_propagation}

%\section{Legion to Antidote flow}
%\label{sec:legion_to_antidote_flow}

%\section{Antidote to Legion flow}
%\label{sec:antidote to legion flow}