\chapter{Integration Design and Architecture}
\label{cha:integration_design_and_architecture}

In this chapter it will be presented the path taken in the integration design process, as well as the architecture on which the implementation has its basis.\par
	The main topics for this section will be displayed as it follows:
\begin{itemize}
\item Technical decisions

\item Components Overview

\item Legion to Antidote flow

\item Antidote to Legion flow
\end{itemize}

\section{Technical decisions}
\label{sec:technical_decisions}
In the starting point of this thesis, the main objective was to integrate Legion with two data storage systems that also used CRDTs, Riak and Antidote. Riak is more enterprise oriented, with several real world use cases, while Antidote is still very fresh and under development. Even thought Antidote uses Riak Core, the two systems diverge a lot based on design options and it's objectives. We started by speaking to a few developers from each of the systems, being able to conclude that Antidote's development environment would be much more beneficial for us regarding support. This was a critical matter since no one directly involved in this thesis was an expert in either of the systems, neither we had much experience in the programming language used (Erlang). With this in mind, we followed to start the integration with Antidote.\par
Our first integration design thought was to use the CRDT's data structures of both systems, translate one to another, and then merge them in order to propagate the state of the system. Once again we talked to the development team as to get a guideline of how this could be done. As we understood, it was not the intended design path to expose the internal CRDT's data structure to the outside of the system. The system's CRDTs were meant to only be accessed as an object abstraction.\par
After acknowledging this, the design of the integration was changed to be based on propagating operations, by executing on one system the operation that was made on the other.


\section{Architecture Overview}
\label{sec:architecture_overview}
Integrating Legion with other storage systems, should be made in a modular and decoupled way, so if one decides to add support for another storage system, the recipe should be similar. This can be achieved by having system components that can easily be replaced.\par
	The following diagram shows the architecture of the integration between the two systems:
	
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{files/architecture.png}
\caption{Integration Architecture}
\label{architecture}
\end{figure}

\par
	The integration of Legion and Antidote can be depicted into the following components:
\begin{description}

\item[Antidote] \hfill \\
The storage system to be integrated with Legion. Antidote will act as a persistent, stable, client-server model storage system. It will be synchronized with Legion, so both will have the entire set of updated objects in the system. An Antidote node can have it's data updated directly from an antidote client, or from an update that was propagated from Legion nodes.\par
Besides that, Antidote will also keep meta-data related to the system synchronization, such as propagated operations identifiers and elements' unique tokens.

\item[Antidote Client] \hfill \\
This component is one of the entry points of information into the system. An Antidote client can manipulate the system's data set by making calls to modify the state of Antidote's objects.\par
	This client is written in javascript and it uses the integration proxy in order to make read and write requests.


\item[Legion Client] \hfill \\
This component is a Legion instance in the system. It acts as an entry point of information to the system and it also as the responsibility to keep it self and the other Legion nodes updated and synchronized.


\item[Legion's Objects Server] \hfill \\
This component keeps a global view of what is happening in the Legion network. There can be one or more objects servers in the system, and Legion's synchronization events will pass through at least one of these. In the objects server also resides the logic for the synchronization between Antidote and Legion. This is done by watching for object update events and then propagating them.\par
This component is written in NodeJS and it uses the integration proxy for the communication with Antidote, by making read and write calls.

\item[Integration Proxy] \hfill \\
This component is needed to establish communication with Antidote. It takes advantage of Antidote's protocol buffer interface to make read and write calls.\par
The proxy can receive requests from either a Antidote client or a Legion's object server synchronization method. The request is parsed and a call is sent to Antidote. When the answer from antidote is received, it is redirected to who made the request. This component is written in NodeJS.

\end{description}

\section{Legion to Antidote flow}
\label{sec:legion_to_antidote_flow}
This section explains the process of propagating an update issued by a Legion node into Antidote.\par
	In order to send the updates from Legion to Antidote we must first detect these updates. To do so, we opted for an event driven model, by relying on Legion's objects server, since every update issued by a Legion node will end up in at least one of the objects servers.\par
	Once the event is detected in the objects server, the incoming message is filtered based on the event type. If the event contained in the message is indeed an update, that objects server will issue one or more update requests to the integration proxy. Once a request reaches the integration proxy, this one will decouple the request into the the actual update data and meta-data. These two are then sent to Antidote as write requests. Besides writing the data into Antidote, the Integration proxy certifies that the operation has not been executed already, since there can be more than one objects server to issue the request. This is done by checking the meta-data stored in Antidote.\par
	Once the update reaches Antidote successfully, the integration proxy returns to the objects server.

\section{Antidote to Legion flow}
\label{sec:antidote to legion flow}
This section explains the process of propagating an update issued by an Antidote client into Legion.\par
	When an Antidote client issues an update, it is firstly sent to the integration Proxy. This one receives the request and creates the needed data and meta-data write requests, sending them to Antidote. The integration proxy returns to the client when the update is successful.\par
	The next step is to send this update to every Legion node. This can be done by sending the update to the objects servers, which will then propagate the message to every node.\par
	At this point there are two methods of sending the update to the objects server. It can be done with a public/subscribe system that fires an event each time an Antidote object is updated, or having Legion's objects servers to probe periodically for new updates on Antidote. The first option would definitely be more performant, because scanning Antidote periodically for updates would have some overhead. With this in mind we talked to the development team in order to know the best way to to this. One alternative was to use Antidote's internal updates propagation mechanism to also fire an event to the exterior, but this solution had two major problems. The update propagation mechanism would not handle lost messages, this would have to be handled by us, and to exposed such internal mechanism to the outside would go against the Antidote's design path. With this, we concluded that we should proceed to the second option.\par
	In order to periodically check for updates in Antidote, we used the system log to get the operations executed since a certain timestamp.\par
	Legion's objects servers will periodically make a request to the integration proxy, in order to check the operations executed in Antidote since the last seen timestamp. The proxy relays the request to antidote and returns the result. If there are no new updates, then the objects server only updates it's last seen timestamp. If there are new updates that were not propagated to legion, the objects server executes the operation locally, and then propagates it to every Legion node.